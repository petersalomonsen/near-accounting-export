#!/usr/bin/env node
// Analyze gaps in account history JSON file
// Detects where balanceBefore does not match balanceAfter of the previous entry

import fs from 'fs';
import { fileURLToPath } from 'url';
import { detectGaps } from './gap-detection.js';
import type { Gap, GapAnalysis, TransactionEntry } from './gap-detection.js';

interface AccountHistory {
    accountId: string;
    createdAt: string;
    updatedAt: string;
    transactions: TransactionEntry[];
    metadata: {
        firstBlock: number | null;
        lastBlock: number | null;
        totalTransactions: number;
    };
}

interface ParsedArgs {
    inputFile: string | null;
    help: boolean;
}

/**
 * Parse command line arguments
 */
function parseArgs(): ParsedArgs {
    const args = process.argv.slice(2);
    const options: ParsedArgs = {
        inputFile: null,
        help: false
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];

        switch (arg) {
            case '--input':
            case '-i':
                if (args[i + 1]) options.inputFile = args[++i] ?? null;
                break;
            case '--help':
            case '-h':
                options.help = true;
                break;
            default:
                // If not a flag and no input file yet, treat as input file
                if (arg && !arg.startsWith('-') && !options.inputFile) {
                    options.inputFile = arg;
                }
        }
    }

    return options;
}

/**
 * Print help message
 */
function printHelp(): void {
    console.log(`
Gap Analysis Tool - Detect balance gaps in NEAR account history

Usage:
  node analyze-gaps.js [options] <input-file>

Options:
  -i, --input <file>    Input JSON file path (required)
  -h, --help            Show this help message

Description:
  Analyzes a JSON file generated by get-account-history.js to detect gaps
  where balanceBefore does not match balanceAfter of the previous entry.

  This helps identify missing transactions or incomplete data collection.

Examples:
  # Analyze gaps in an account history file
  node analyze-gaps.js myaccount.near.json

  # Using long options
  node analyze-gaps.js --input myaccount.near.json
`);
}

/**
 * Format a balance snapshot for display
 */
function formatBalance(balance: any): string {
    const parts: string[] = [];

    if (balance?.near && balance.near !== '0') {
        parts.push(`NEAR: ${balance.near}`);
    }

    if (balance?.fungibleTokens) {
        for (const [token, amount] of Object.entries(balance.fungibleTokens)) {
            if (amount !== '0') {
                parts.push(`${token}: ${amount}`);
            }
        }
    }

    if (balance?.intentsTokens) {
        for (const [token, amount] of Object.entries(balance.intentsTokens)) {
            if (amount !== '0') {
                parts.push(`INTENT:${token}: ${amount}`);
            }
        }
    }

    if (balance?.stakingPools) {
        for (const [pool, amount] of Object.entries(balance.stakingPools)) {
            if (amount !== '0') {
                parts.push(`STAKING:${pool}: ${amount}`);
            }
        }
    }

    return parts.length > 0 ? parts.join(', ') : 'All zeros';
}

/**
 * Print gap details
 */
function printGap(gap: Gap, index: number): void {
    console.log(`\n${'='.repeat(80)}`);
    console.log(`Gap #${index + 1}: Blocks ${gap.startBlock} -> ${gap.endBlock}`);
    console.log(`${'='.repeat(80)}`);

    console.log(`\nPrevious transaction (block ${gap.prevTransaction.block}):`);
    console.log(`  Balance After: ${formatBalance(gap.prevTransaction.balanceAfter)}`);

    console.log(`\nNext transaction (block ${gap.nextTransaction.block}):`);
    console.log(`  Balance Before: ${formatBalance(gap.nextTransaction.balanceBefore)}`);

    console.log(`\nMismatches:`);
    for (const error of gap.verification.errors) {
        console.log(`  ❌ ${error.message}`);
        console.log(`     Expected: ${error.expected}`);
        console.log(`     Actual:   ${error.actual}`);
        if (error.token) {
            console.log(`     Token:    ${error.token}`);
        }
        if (error.pool) {
            console.log(`     Pool:     ${error.pool}`);
        }
    }
}

/**
 * Print summary statistics
 */
function printSummary(analysis: GapAnalysis, history: AccountHistory): void {
    console.log(`\n${'='.repeat(80)}`);
    console.log('SUMMARY');
    console.log(`${'='.repeat(80)}`);

    console.log(`\nAccount: ${history.accountId}`);
    console.log(`Total Transactions: ${history.transactions.length}`);
    console.log(`Block Range: ${history.metadata.firstBlock} -> ${history.metadata.lastBlock}`);

    console.log(`\nGap Analysis Results:`);
    console.log(`  Total Gaps Found: ${analysis.totalGaps}`);
    console.log(`  Internal Gaps: ${analysis.internalGaps.length}`);
    console.log(`  Gap to Creation: ${analysis.gapToCreation ? 'Yes' : 'No'}`);
    console.log(`  Gap to Present: ${analysis.gapToPresent ? 'Yes (requires current balance check)' : 'No check performed'}`);
    console.log(`  History Complete: ${analysis.isComplete ? '✅ Yes' : '❌ No'}`);

    if (analysis.totalGaps > 0) {
        console.log(`\n⚠️  Found ${analysis.totalGaps} gap(s) in the transaction history.`);
        console.log(`   This indicates missing transactions or incomplete data collection.`);
    } else {
        console.log(`\n✅ No gaps found! The transaction history is complete.`);
    }
}

/**
 * Main execution
 */
async function main(): Promise<void> {
    const options = parseArgs();

    if (options.help) {
        printHelp();
        process.exit(0);
    }

    if (!options.inputFile) {
        console.error('Error: Input file is required');
        printHelp();
        process.exit(1);
    }

    // Check if input file exists
    if (!fs.existsSync(options.inputFile)) {
        console.error(`Error: Input file not found: ${options.inputFile}`);
        process.exit(1);
    }

    try {
        // Read and parse input file
        console.log(`Reading input file: ${options.inputFile}`);
        const inputData = fs.readFileSync(options.inputFile, 'utf-8');
        const history: AccountHistory = JSON.parse(inputData);

        // Validate basic structure
        if (!history.accountId || !Array.isArray(history.transactions)) {
            console.error('Error: Invalid JSON structure - missing accountId or transactions array');
            process.exit(1);
        }

        console.log(`Analyzing gaps for account: ${history.accountId}`);
        console.log(`Total transactions: ${history.transactions.length}`);

        // Run gap detection
        const analysis: GapAnalysis = detectGaps(history.transactions);

        // Print results
        if (analysis.gapToCreation) {
            printGap(analysis.gapToCreation, 0);
        }

        analysis.internalGaps.forEach((gap, index) => {
            const offset = analysis.gapToCreation ? 1 : 0;
            printGap(gap, index + offset);
        });

        if (analysis.gapToPresent) {
            const offset = (analysis.gapToCreation ? 1 : 0) + analysis.internalGaps.length;
            printGap(analysis.gapToPresent, offset);
        }

        // Print summary
        printSummary(analysis, history);

        // Exit with appropriate code
        process.exit(analysis.isComplete ? 0 : 1);
    } catch (error: unknown) {
        const message = error instanceof Error ? error.message : String(error);
        console.error(`Error: ${message}`);
        process.exit(1);
    }
}

// Run if called directly
if (import.meta.url.startsWith('file:') && process.argv[1] === fileURLToPath(import.meta.url)) {
    main();
}

// Export for testing
export { printGap, printSummary, formatBalance };
export type { AccountHistory };
