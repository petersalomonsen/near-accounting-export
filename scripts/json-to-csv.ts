#!/usr/bin/env node
// Convert JSON accounting history to CSV format
// Reads the JSON file generated by get-account-history.ts and outputs a CSV file

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { getTokenMetadata, formatTokenAmount } from './token-metadata.js';

// Types matching the data structures from get-account-history.ts
interface TransferDetail {
    type: 'near' | 'ft' | 'mt' | 'staking_reward';
    direction: 'in' | 'out';
    amount: string;
    counterparty: string;
    tokenId?: string;
    memo?: string;
    txHash?: string;
    receiptId?: string;
}

interface BalanceSnapshot {
    near: string;
    fungibleTokens: Record<string, string>;
    intentsTokens: Record<string, string>;
    stakingPools?: Record<string, string>;
}

interface TransactionEntry {
    block: number;
    transactionBlock?: number | null;
    timestamp: number | null;
    transactionHashes: string[];
    transfers?: TransferDetail[];
    balanceAfter?: BalanceSnapshot;
}

interface AccountHistory {
    accountId: string;
    createdAt: string;
    updatedAt: string;
    transactions: TransactionEntry[];
    metadata: {
        firstBlock: number | null;
        lastBlock: number | null;
        totalTransactions: number;
    };
}

interface CSVRow {
    changeBlockHeight: number;
    timestamp: string;
    counterparty: string;
    direction: 'in' | 'out';
    tokenSymbol: string;
    amountWholeUnits: string;
    balanceWholeUnits: string;
    asset: string;
    amountRaw: string;
    tokenBalanceRaw: string;
    transactionHash: string;
    receiptId: string;
}

interface ParsedArgs {
    inputFile: string | null;
    outputFile: string | null;
    help: boolean;
}

/**
 * Escape a value for CSV output
 * Wraps values containing commas, quotes, or newlines in double quotes
 * and escapes internal double quotes by doubling them
 */
function escapeCSV(value: string): string {
    if (value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r')) {
        return `"${value.replace(/"/g, '""')}"`;
    }
    return value;
}

/**
 * Convert NEAR timestamp (nanoseconds) to ISO date string
 */
function formatTimestamp(timestamp: number | null): string {
    if (timestamp === null) {
        return '';
    }
    // NEAR timestamps are in nanoseconds, convert to milliseconds
    const ms = Math.floor(timestamp / 1_000_000);
    return new Date(ms).toISOString();
}

/**
 * Get the asset name for a transfer
 */
function getAssetName(transfer: TransferDetail): string {
    if (transfer.type === 'near') {
        return 'NEAR';
    }
    if (transfer.type === 'staking_reward') {
        return `STAKING:${transfer.tokenId || transfer.counterparty}`;
    }
    // For FT and MT transfers, use the tokenId
    return transfer.tokenId || 'unknown';
}

/**
 * Get the token balance after the transaction for the given transfer type
 */
function getTokenBalance(transfer: TransferDetail, balanceAfter: BalanceSnapshot | undefined): string {
    if (!balanceAfter) {
        return '';
    }

    if (transfer.type === 'near') {
        return balanceAfter.near || '0';
    }

    if (transfer.type === 'ft' && transfer.tokenId) {
        return balanceAfter.fungibleTokens?.[transfer.tokenId] || '0';
    }

    if (transfer.type === 'mt' && transfer.tokenId) {
        return balanceAfter.intentsTokens?.[transfer.tokenId] || '0';
    }

    if (transfer.type === 'staking_reward' && transfer.tokenId) {
        return balanceAfter.stakingPools?.[transfer.tokenId] || '0';
    }

    return '';
}

/**
 * Convert account history to CSV rows
 */
async function convertToCSVRows(history: AccountHistory): Promise<CSVRow[]> {
    const rows: CSVRow[] = [];

    for (const transaction of history.transactions) {
        if (!transaction.transfers || transaction.transfers.length === 0) {
            continue;
        }

        for (const transfer of transaction.transfers) {
            // Get asset name (contract ID or "NEAR")
            const asset = getAssetName(transfer);
            
            // Get token metadata for symbol and decimals
            const metadata = await getTokenMetadata(
                asset === 'NEAR' ? 'NEAR' : (transfer.tokenId || asset),
                transfer.type
            );
            
            // Format amount and balance with decimals
            const amountWholeUnits = formatTokenAmount(transfer.amount || '0', metadata.decimals);
            const tokenBalanceRaw = getTokenBalance(transfer, transaction.balanceAfter);
            const balanceWholeUnits = formatTokenAmount(tokenBalanceRaw, metadata.decimals);
            
            const row: CSVRow = {
                changeBlockHeight: transaction.block,
                timestamp: formatTimestamp(transaction.timestamp),
                counterparty: transfer.counterparty || '',
                direction: transfer.direction,
                tokenSymbol: metadata.symbol,
                amountWholeUnits,
                balanceWholeUnits,
                asset: asset,
                amountRaw: transfer.amount || '',
                tokenBalanceRaw,
                transactionHash: transfer.txHash || (transaction.transactionHashes.length > 0 ? transaction.transactionHashes[0] || '' : ''),
                receiptId: transfer.receiptId || ''
            };
            rows.push(row);
        }
    }

    return rows;
}

/**
 * Generate CSV content from rows
 * Sorts rows by change_block_height (ascending)
 */
function generateCSV(rows: CSVRow[]): string {
    // Sort by change block height (ascending order)
    const sortedRows = [...rows].sort((a, b) => a.changeBlockHeight - b.changeBlockHeight);
    
    const headers = [
        'change_block_height',
        'timestamp',
        'counterparty',
        'direction',
        'token_symbol',
        'amount_whole_units',
        'balance_whole_units',
        'asset',
        'amount_raw',
        'token_balance_raw',
        'transaction_hash',
        'receipt_id'
    ];

    const lines: string[] = [headers.join(',')];

    for (const row of sortedRows) {
        const values = [
            String(row.changeBlockHeight),
            escapeCSV(row.timestamp),
            escapeCSV(row.counterparty),
            escapeCSV(row.direction),
            escapeCSV(row.tokenSymbol),
            escapeCSV(row.amountWholeUnits),
            escapeCSV(row.balanceWholeUnits),
            escapeCSV(row.asset),
            // Wrap raw values in quotes to preserve as strings (prevent Excel scientific notation)
            `"${row.amountRaw}"`,
            `"${row.tokenBalanceRaw}"`,
            escapeCSV(row.transactionHash),
            escapeCSV(row.receiptId)
        ];
        lines.push(values.join(','));
    }

    return lines.join('\n');
}

/**
 * Parse command line arguments
 */
function parseArgs(): ParsedArgs {
    const args = process.argv.slice(2);
    const options: ParsedArgs = {
        inputFile: null,
        outputFile: null,
        help: false
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];

        switch (arg) {
            case '--input':
            case '-i':
                if (args[i + 1]) options.inputFile = args[++i] ?? null;
                break;
            case '--output':
            case '-o':
                if (args[i + 1]) options.outputFile = args[++i] ?? null;
                break;
            case '--help':
            case '-h':
                options.help = true;
                break;
            default:
                // If not a flag and no input file yet, treat as input file
                if (arg && !arg.startsWith('-') && !options.inputFile) {
                    options.inputFile = arg;
                }
        }
    }

    return options;
}

/**
 * Print help message
 */
function printHelp(): void {
    console.log(`
JSON to CSV Converter - Convert NEAR accounting history JSON to CSV

Usage:
  node json-to-csv.js [options] <input-file>

Options:
  -i, --input <file>    Input JSON file path (required)
  -o, --output <file>   Output CSV file path (optional, defaults to input file with .csv extension)
  -h, --help            Show this help message

Description:
  Reads a JSON file generated by get-account-history.js and converts it to a CSV file
  suitable for import into spreadsheet software.

  Note: Timestamps must be present in the JSON data. If timestamps are missing, 
  re-run the data collection script (get-account-history.js) with the --enrich flag
  to fetch missing timestamps.

  The CSV file contains the following columns (human-friendly on left, technical on right):
    - change_block_height: Block where balance change occurred (used for sorting)
    - timestamp: ISO 8601 timestamp of the transfer
    - counterparty: The other account involved in the transfer
    - direction: "in" for incoming transfers, "out" for outgoing transfers
    - token_symbol: Human-readable token symbol (NEAR, USDT, wNEAR, etc.)
    - amount_whole_units: Amount transferred in whole units (with decimals applied)
    - balance_whole_units: Token balance after transfer (with decimals applied)
    - asset: Token contract ID (NEAR for native, contract address for FT/MT)
    - amount_raw: Amount transferred in base units (as string to prevent Excel issues)
    - token_balance_raw: Token balance in base units (as string)
    - transaction_hash: Transaction hash (can be used to look up transaction in explorers)
    - receipt_id: Receipt ID of the transfer

Examples:
  # Convert a JSON file to CSV
  node json-to-csv.js myaccount.near.json

  # Specify output file
  node json-to-csv.js -i myaccount.near.json -o accounting.csv

  # Using long options
  node json-to-csv.js --input myaccount.near.json --output accounting.csv
`);
}

/**
 * Main execution
 */
async function main(): Promise<void> {
    const options = parseArgs();

    if (options.help) {
        printHelp();
        process.exit(0);
    }

    if (!options.inputFile) {
        console.error('Error: Input file is required');
        printHelp();
        process.exit(1);
    }

    // Check if input file exists
    if (!fs.existsSync(options.inputFile)) {
        console.error(`Error: Input file not found: ${options.inputFile}`);
        process.exit(1);
    }

    // Set default output file
    if (!options.outputFile) {
        const inputPath = path.parse(options.inputFile);
        options.outputFile = path.join(inputPath.dir, `${inputPath.name}.csv`);
    }

    try {
        // Read and parse input file
        console.log(`Reading input file: ${options.inputFile}`);
        const inputData = fs.readFileSync(options.inputFile, 'utf-8');
        const history: AccountHistory = JSON.parse(inputData);

        // Validate basic structure
        if (!history.accountId || !Array.isArray(history.transactions)) {
            console.error('Error: Invalid JSON structure - missing accountId or transactions array');
            process.exit(1);
        }

        // Check for missing timestamps
        const transactionsWithTransfers = history.transactions.filter(t => t.transfers && t.transfers.length > 0);
        const missingTimestamps = transactionsWithTransfers.filter(t => t.timestamp === null).length;
        if (missingTimestamps > 0) {
            console.warn(`Warning: ${missingTimestamps} transaction(s) have missing timestamps.`);
            console.warn(`Run 'npm start -- --account ${history.accountId} --enrich' to fetch missing timestamps.`);
        }

        // Convert to CSV rows (now async)
        console.log('Fetching token metadata and converting to CSV...');
        const rows = await convertToCSVRows(history);
        console.log(`Found ${rows.length} transfers to export`);

        // Generate CSV content
        const csvContent = generateCSV(rows);

        // Write output file
        const outputDir = path.dirname(options.outputFile);
        if (outputDir && !fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(options.outputFile, csvContent);

        console.log(`CSV exported to: ${options.outputFile}`);
        console.log(`Total rows: ${rows.length}`);
    } catch (error: unknown) {
        const message = error instanceof Error ? error.message : String(error);
        console.error(`Error: ${message}`);
        process.exit(1);
    }
}

// Run if called directly
if (import.meta.url.startsWith('file:') && process.argv[1] === fileURLToPath(import.meta.url)) {
    main();
}

// Export for testing
export {
    convertToCSVRows,
    generateCSV,
    escapeCSV,
    formatTimestamp,
    getAssetName,
    getTokenBalance
};
export type { AccountHistory, TransactionEntry, TransferDetail, BalanceSnapshot, CSVRow };
