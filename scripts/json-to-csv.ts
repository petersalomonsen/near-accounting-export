#!/usr/bin/env node
// Convert JSON accounting history to CSV format
// Reads the V2 JSON file generated by get-account-history.ts and outputs a CSV file

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { getTokenMetadata, formatTokenAmount } from './token-metadata.js';
import type { BalanceChangeRecord } from './balance-tracker.js';

// V2 format (flat BalanceChangeRecord format)
interface AccountHistoryV2 {
    version: 2;
    accountId: string;
    createdAt: string;
    updatedAt: string;
    records: BalanceChangeRecord[];
    stakingPools?: string[];
    metadata: {
        firstBlock: number | null;
        lastBlock: number | null;
        totalRecords: number;
        historyComplete?: boolean;
    };
}

interface CSVRow {
    changeBlockHeight: number;
    timestamp: string;
    counterparty: string;
    direction: 'in' | 'out';
    tokenSymbol: string;
    amountWholeUnits: string;
    balanceWholeUnits: string;
    asset: string;
    amountRaw: string;
    tokenBalanceRaw: string;
    transactionHash: string;
    receiptId: string;
}

interface ParsedArgs {
    inputFile: string | null;
    outputFile: string | null;
    help: boolean;
}

/**
 * Escape a value for CSV output
 * Wraps values containing commas, quotes, or newlines in double quotes
 * and escapes internal double quotes by doubling them
 */
function escapeCSV(value: string): string {
    if (value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r')) {
        return `"${value.replace(/"/g, '""')}"`;
    }
    return value;
}

/**
 * Check if the data is in V2 format
 */
function isV2Format(data: any): data is AccountHistoryV2 {
    return data.version === 2 && Array.isArray(data.records);
}

/**
 * Convert BalanceChangeRecords to CSV rows
 */
async function convertToCSVRows(records: BalanceChangeRecord[]): Promise<CSVRow[]> {
    const rows: CSVRow[] = [];

    for (const record of records) {
        // Determine token type from token_id
        const tokenType = record.token_id === 'near' ? 'near' :
            record.token_id.startsWith('nep141:') ? 'mt' :
            record.token_id.includes('.pool') ? 'staking_reward' : 'ft';

        const metadata = await getTokenMetadata(record.token_id, tokenType);

        // Calculate direction and absolute amount from the signed amount
        const amountBigInt = BigInt(record.amount);
        const direction: 'in' | 'out' = amountBigInt >= 0n ? 'in' : 'out';
        const absAmount = amountBigInt >= 0n ? record.amount : record.amount.substring(1);

        // Determine asset name
        const asset = tokenType === 'staking_reward' ? `STAKING:${record.token_id}` :
            record.token_id === 'near' ? 'NEAR' : record.token_id;

        rows.push({
            changeBlockHeight: record.block_height,
            timestamp: record.block_timestamp || '',
            counterparty: record.counterparty || '',
            direction,
            tokenSymbol: metadata.symbol,
            amountWholeUnits: formatTokenAmount(absAmount, metadata.decimals),
            balanceWholeUnits: formatTokenAmount(record.balance_after, metadata.decimals),
            asset,
            amountRaw: absAmount,
            tokenBalanceRaw: record.balance_after,
            transactionHash: record.tx_hash || '',
            receiptId: record.receipt_id || ''
        });
    }

    return rows;
}

/**
 * Generate CSV content from rows
 * Sorts rows by change_block_height (ascending)
 */
function generateCSV(rows: CSVRow[]): string {
    // Sort by change block height (ascending order)
    const sortedRows = [...rows].sort((a, b) => a.changeBlockHeight - b.changeBlockHeight);

    const headers = [
        'change_block_height',
        'timestamp',
        'counterparty',
        'direction',
        'token_symbol',
        'amount_whole_units',
        'balance_whole_units',
        'asset',
        'amount_raw',
        'token_balance_raw',
        'transaction_hash',
        'receipt_id'
    ];

    const lines: string[] = [headers.join(',')];

    for (const row of sortedRows) {
        const values = [
            String(row.changeBlockHeight),
            escapeCSV(row.timestamp),
            escapeCSV(row.counterparty),
            escapeCSV(row.direction),
            escapeCSV(row.tokenSymbol),
            escapeCSV(row.amountWholeUnits),
            escapeCSV(row.balanceWholeUnits),
            escapeCSV(row.asset),
            row.amountRaw,
            row.tokenBalanceRaw,
            escapeCSV(row.transactionHash),
            escapeCSV(row.receiptId)
        ];
        lines.push(values.join(','));
    }

    return lines.join('\n');
}

/**
 * Parse command line arguments
 */
function parseArgs(): ParsedArgs {
    const args = process.argv.slice(2);
    const options: ParsedArgs = {
        inputFile: null,
        outputFile: null,
        help: false
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];

        switch (arg) {
            case '--input':
            case '-i':
                if (args[i + 1]) options.inputFile = args[++i] ?? null;
                break;
            case '--output':
            case '-o':
                if (args[i + 1]) options.outputFile = args[++i] ?? null;
                break;
            case '--help':
            case '-h':
                options.help = true;
                break;
            default:
                // If not a flag and no input file yet, treat as input file
                if (arg && !arg.startsWith('-') && !options.inputFile) {
                    options.inputFile = arg;
                }
        }
    }

    return options;
}

/**
 * Print help message
 */
function printHelp(): void {
    console.log(`
JSON to CSV Converter - Convert NEAR accounting history JSON to CSV

Usage:
  node json-to-csv.js [options] <input-file>

Options:
  -i, --input <file>    Input JSON file path (required)
  -o, --output <file>   Output CSV file path (optional, defaults to input file with .csv extension)
  -h, --help            Show this help message

Description:
  Reads a V2 JSON file generated by get-account-history.js and converts it to a CSV file
  suitable for import into spreadsheet software.

  The CSV file contains the following columns:
    - change_block_height: Block where balance change occurred
    - timestamp: ISO 8601 timestamp of the change
    - counterparty: The other account involved in the transfer
    - direction: "in" for incoming, "out" for outgoing
    - token_symbol: Human-readable token symbol (NEAR, USDT, wNEAR, etc.)
    - amount_whole_units: Amount in whole units (with decimals applied)
    - balance_whole_units: Token balance after change (with decimals applied)
    - asset: Token ID (NEAR for native, contract address for FT/MT)
    - amount_raw: Amount in base units
    - token_balance_raw: Token balance in base units
    - transaction_hash: Transaction hash
    - receipt_id: Receipt ID

Examples:
  node json-to-csv.js myaccount.near.json
  node json-to-csv.js -i myaccount.near.json -o accounting.csv
`);
}

/**
 * Main execution
 */
async function main(): Promise<void> {
    const options = parseArgs();

    if (options.help) {
        printHelp();
        process.exit(0);
    }

    if (!options.inputFile) {
        console.error('Error: Input file is required');
        printHelp();
        process.exit(1);
    }

    // Check if input file exists
    if (!fs.existsSync(options.inputFile)) {
        console.error(`Error: Input file not found: ${options.inputFile}`);
        process.exit(1);
    }

    // Set default output file
    if (!options.outputFile) {
        const inputPath = path.parse(options.inputFile);
        options.outputFile = path.join(inputPath.dir, `${inputPath.name}.csv`);
    }

    try {
        // Read and parse input file
        console.log(`Reading input file: ${options.inputFile}`);
        const inputData = fs.readFileSync(options.inputFile, 'utf-8');
        const history = JSON.parse(inputData);

        // Validate V2 format
        if (!history.accountId) {
            console.error('Error: Invalid JSON structure - missing accountId');
            process.exit(1);
        }

        if (!isV2Format(history)) {
            console.error('Error: Only V2 format is supported. Run migration script to convert.');
            console.error('  npx tsx scripts/migrate-to-flat-format.ts ' + options.inputFile);
            process.exit(1);
        }

        console.log(`Found ${history.records.length} records`);

        // Check for missing timestamps
        const missingTimestamps = history.records.filter((r: BalanceChangeRecord) => !r.block_timestamp).length;
        if (missingTimestamps > 0) {
            console.warn(`Warning: ${missingTimestamps} record(s) have missing timestamps.`);
        }

        // Convert to CSV rows
        console.log('Fetching token metadata and converting to CSV...');
        const rows = await convertToCSVRows(history.records);
        console.log(`Found ${rows.length} records to export`);

        // Generate CSV content
        const csvContent = generateCSV(rows);

        // Write output file
        const outputDir = path.dirname(options.outputFile);
        if (outputDir && !fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(options.outputFile, csvContent);

        console.log(`CSV exported to: ${options.outputFile}`);
        console.log(`Total rows: ${rows.length}`);
    } catch (error: unknown) {
        const message = error instanceof Error ? error.message : String(error);
        console.error(`Error: ${message}`);
        process.exit(1);
    }
}

/**
 * Convert JSON file to CSV file (programmatic API)
 */
export async function convertJsonToCsv(inputFile: string, outputFile: string): Promise<void> {
    // Check if input file exists
    if (!fs.existsSync(inputFile)) {
        throw new Error(`Input file not found: ${inputFile}`);
    }

    // Read and parse input file
    const inputData = fs.readFileSync(inputFile, 'utf-8');
    const history = JSON.parse(inputData);

    // Validate format
    if (!history.accountId) {
        throw new Error('Invalid JSON structure - missing accountId');
    }

    if (!isV2Format(history)) {
        throw new Error('Only V2 format is supported. Run migration script to convert.');
    }

    // Convert to CSV rows
    const rows = await convertToCSVRows(history.records);

    // Generate CSV content
    const csvContent = generateCSV(rows);

    // Write output file
    const outputDir = path.dirname(outputFile);
    if (outputDir && !fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    fs.writeFileSync(outputFile, csvContent);
}

// Run if called directly
if (import.meta.url.startsWith('file:') && process.argv[1] === fileURLToPath(import.meta.url)) {
    main();
}

// Export for testing
export {
    convertToCSVRows,
    generateCSV,
    escapeCSV,
    isV2Format
};
export type { AccountHistoryV2, CSVRow };
