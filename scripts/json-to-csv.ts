#!/usr/bin/env node
// Convert JSON accounting history to CSV format
// Reads the JSON file generated by get-account-history.ts and outputs a CSV file

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { getTokenMetadata, formatTokenAmount } from './token-metadata.js';

// Types matching the data structures from get-account-history.ts
interface TransferDetail {
    type: 'near' | 'ft' | 'mt' | 'staking_reward' | 'action_receipt_gas_reward';
    direction: 'in' | 'out';
    amount: string;
    counterparty: string;
    tokenId?: string;
    memo?: string;
    txHash?: string;
    receiptId?: string;
}

interface BalanceSnapshot {
    near: string;
    fungibleTokens: Record<string, string>;
    intentsTokens: Record<string, string>;
    stakingPools?: Record<string, string>;
}

interface BalanceChange {
    start: string;
    end: string;
    diff: string;
}

interface Changes {
    nearChanged: boolean;
    nearDiff?: string;
    tokensChanged: Record<string, BalanceChange>;
    intentsChanged: Record<string, BalanceChange>;
    stakingChanged?: Record<string, BalanceChange>;
}

interface TransactionEntry {
    block: number;
    transactionBlock?: number | null;
    timestamp: number | null;
    transactionHashes: string[];
    transfers?: TransferDetail[];
    balanceBefore?: BalanceSnapshot;
    balanceAfter?: BalanceSnapshot;
    changes?: Changes;
}

interface AccountHistory {
    accountId: string;
    createdAt: string;
    updatedAt: string;
    transactions: TransactionEntry[];
    metadata: {
        firstBlock: number | null;
        lastBlock: number | null;
        totalTransactions: number;
    };
}

interface CSVRow {
    changeBlockHeight: number;
    timestamp: string;
    counterparty: string;
    direction: 'in' | 'out';
    tokenSymbol: string;
    amountWholeUnits: string;
    balanceWholeUnits: string;
    asset: string;
    amountRaw: string;
    tokenBalanceRaw: string;
    transactionHash: string;
    receiptId: string;
}

interface ParsedArgs {
    inputFile: string | null;
    outputFile: string | null;
    help: boolean;
}

/**
 * Escape a value for CSV output
 * Wraps values containing commas, quotes, or newlines in double quotes
 * and escapes internal double quotes by doubling them
 */
function escapeCSV(value: string): string {
    if (value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r')) {
        return `"${value.replace(/"/g, '""')}"`;
    }
    return value;
}

/**
 * Convert NEAR timestamp (nanoseconds) to ISO date string
 */
function formatTimestamp(timestamp: number | null): string {
    if (timestamp === null) {
        return '';
    }
    // NEAR timestamps are in nanoseconds, convert to milliseconds
    const ms = Math.floor(timestamp / 1_000_000);
    return new Date(ms).toISOString();
}

/**
 * Get the asset name for a transfer
 */
function getAssetName(transfer: TransferDetail): string {
    if (transfer.type === 'near') {
        return 'NEAR';
    }
    if (transfer.type === 'staking_reward') {
        return `STAKING:${transfer.tokenId || transfer.counterparty}`;
    }
    // For FT and MT transfers, use the tokenId
    return transfer.tokenId || 'unknown';
}

/**
 * Get the token balance after the transaction for the given transfer type
 */
function getTokenBalance(transfer: TransferDetail, balanceAfter: BalanceSnapshot | undefined): string {
    if (!balanceAfter) {
        return '';
    }

    if (transfer.type === 'near') {
        return balanceAfter.near || '0';
    }

    if (transfer.type === 'ft' && transfer.tokenId) {
        return balanceAfter.fungibleTokens?.[transfer.tokenId] || '0';
    }

    if (transfer.type === 'mt' && transfer.tokenId) {
        return balanceAfter.intentsTokens?.[transfer.tokenId] || '0';
    }

    if (transfer.type === 'staking_reward' && transfer.tokenId) {
        return balanceAfter.stakingPools?.[transfer.tokenId] || '0';
    }

    return '';
}

/**
 * Convert account history to CSV rows based on actual balance changes
 * Creates one row per asset that changed in each block
 */
async function convertToCSVRows(history: AccountHistory): Promise<CSVRow[]> {
    const rows: CSVRow[] = [];

    for (const transaction of history.transactions) {
        const changes = transaction.changes;
        if (!changes) {
            continue;
        }

        const timestamp = formatTimestamp(transaction.timestamp);
        const txHash = transaction.transactionHashes.length > 0 ? transaction.transactionHashes[0] || '' : '';
        
        // Find matching transfer for counterparty info (best effort)
        const findTransferForAsset = (asset: string, type: 'near' | 'ft' | 'mt' | 'staking_reward'): TransferDetail | undefined => {
            if (!transaction.transfers) return undefined;
            return transaction.transfers.find(t => {
                if (type === 'near') return t.type === 'near' || t.type === 'action_receipt_gas_reward';
                if (type === 'mt') return t.type === 'mt' && t.tokenId === asset;
                if (type === 'ft') return t.type === 'ft' && t.tokenId === asset;
                if (type === 'staking_reward') return t.type === 'staking_reward' && t.tokenId === asset;
                return false;
            });
        };

        // Process NEAR changes
        if (changes.nearChanged && changes.nearDiff) {
            const diff = BigInt(changes.nearDiff);
            const direction: 'in' | 'out' = diff >= 0n ? 'in' : 'out';
            const amount = diff >= 0n ? changes.nearDiff : changes.nearDiff.substring(1); // Remove leading minus
            const balanceRaw = transaction.balanceAfter?.near || '0';
            
            const metadata = await getTokenMetadata('NEAR', 'near');
            const matchingTransfer = findTransferForAsset('NEAR', 'near');
            
            rows.push({
                changeBlockHeight: transaction.block,
                timestamp,
                counterparty: matchingTransfer?.counterparty || '',
                direction,
                tokenSymbol: metadata.symbol,
                amountWholeUnits: formatTokenAmount(amount, metadata.decimals),
                balanceWholeUnits: formatTokenAmount(balanceRaw, metadata.decimals),
                asset: 'NEAR',
                amountRaw: amount,
                tokenBalanceRaw: balanceRaw,
                transactionHash: matchingTransfer?.txHash || txHash,
                receiptId: matchingTransfer?.receiptId || ''
            });
        }

        // Process fungible token changes
        for (const [tokenId, change] of Object.entries(changes.tokensChanged)) {
            const diff = BigInt(change.diff);
            const direction: 'in' | 'out' = diff >= 0n ? 'in' : 'out';
            const amount = diff >= 0n ? change.diff : change.diff.substring(1);
            const balanceRaw = transaction.balanceAfter?.fungibleTokens?.[tokenId] || '0';
            
            const metadata = await getTokenMetadata(tokenId, 'ft');
            const matchingTransfer = findTransferForAsset(tokenId, 'ft');
            
            rows.push({
                changeBlockHeight: transaction.block,
                timestamp,
                counterparty: matchingTransfer?.counterparty || '',
                direction,
                tokenSymbol: metadata.symbol,
                amountWholeUnits: formatTokenAmount(amount, metadata.decimals),
                balanceWholeUnits: formatTokenAmount(balanceRaw, metadata.decimals),
                asset: tokenId,
                amountRaw: amount,
                tokenBalanceRaw: balanceRaw,
                transactionHash: matchingTransfer?.txHash || txHash,
                receiptId: matchingTransfer?.receiptId || ''
            });
        }

        // Process intents (multi-token) changes
        for (const [tokenId, change] of Object.entries(changes.intentsChanged)) {
            const diff = BigInt(change.diff);
            const direction: 'in' | 'out' = diff >= 0n ? 'in' : 'out';
            const amount = diff >= 0n ? change.diff : change.diff.substring(1);
            const balanceRaw = transaction.balanceAfter?.intentsTokens?.[tokenId] || '0';
            
            const metadata = await getTokenMetadata(tokenId, 'mt');
            const matchingTransfer = findTransferForAsset(tokenId, 'mt');
            
            rows.push({
                changeBlockHeight: transaction.block,
                timestamp,
                counterparty: matchingTransfer?.counterparty || '',
                direction,
                tokenSymbol: metadata.symbol,
                amountWholeUnits: formatTokenAmount(amount, metadata.decimals),
                balanceWholeUnits: formatTokenAmount(balanceRaw, metadata.decimals),
                asset: tokenId,
                amountRaw: amount,
                tokenBalanceRaw: balanceRaw,
                transactionHash: matchingTransfer?.txHash || txHash,
                receiptId: matchingTransfer?.receiptId || ''
            });
        }

        // Process staking changes
        if (changes.stakingChanged) {
            for (const [poolId, change] of Object.entries(changes.stakingChanged)) {
                const diff = BigInt(change.diff);
                const direction: 'in' | 'out' = diff >= 0n ? 'in' : 'out';
                const amount = diff >= 0n ? change.diff : change.diff.substring(1);
                const balanceRaw = transaction.balanceAfter?.stakingPools?.[poolId] || '0';
                
                const metadata = await getTokenMetadata(poolId, 'staking_reward');
                const matchingTransfer = findTransferForAsset(poolId, 'staking_reward');
                
                rows.push({
                    changeBlockHeight: transaction.block,
                    timestamp,
                    counterparty: matchingTransfer?.counterparty || poolId,
                    direction,
                    tokenSymbol: metadata.symbol,
                    amountWholeUnits: formatTokenAmount(amount, metadata.decimals),
                    balanceWholeUnits: formatTokenAmount(balanceRaw, metadata.decimals),
                    asset: `STAKING:${poolId}`,
                    amountRaw: amount,
                    tokenBalanceRaw: balanceRaw,
                    transactionHash: matchingTransfer?.txHash || txHash,
                    receiptId: matchingTransfer?.receiptId || ''
                });
            }
        }
    }

    return rows;
}

/**
 * Generate CSV content from rows
 * Sorts rows by change_block_height (ascending)
 */
function generateCSV(rows: CSVRow[]): string {
    // Sort by change block height (ascending order)
    const sortedRows = [...rows].sort((a, b) => a.changeBlockHeight - b.changeBlockHeight);
    
    const headers = [
        'change_block_height',
        'timestamp',
        'counterparty',
        'direction',
        'token_symbol',
        'amount_whole_units',
        'balance_whole_units',
        'asset',
        'amount_raw',
        'token_balance_raw',
        'transaction_hash',
        'receipt_id'
    ];

    const lines: string[] = [headers.join(',')];

    for (const row of sortedRows) {
        const values = [
            String(row.changeBlockHeight),
            escapeCSV(row.timestamp),
            escapeCSV(row.counterparty),
            escapeCSV(row.direction),
            escapeCSV(row.tokenSymbol),
            escapeCSV(row.amountWholeUnits),
            escapeCSV(row.balanceWholeUnits),
            escapeCSV(row.asset),
            row.amountRaw,
            row.tokenBalanceRaw,
            escapeCSV(row.transactionHash),
            escapeCSV(row.receiptId)
        ];
        lines.push(values.join(','));
    }

    return lines.join('\n');
}

/**
 * Parse command line arguments
 */
function parseArgs(): ParsedArgs {
    const args = process.argv.slice(2);
    const options: ParsedArgs = {
        inputFile: null,
        outputFile: null,
        help: false
    };

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];

        switch (arg) {
            case '--input':
            case '-i':
                if (args[i + 1]) options.inputFile = args[++i] ?? null;
                break;
            case '--output':
            case '-o':
                if (args[i + 1]) options.outputFile = args[++i] ?? null;
                break;
            case '--help':
            case '-h':
                options.help = true;
                break;
            default:
                // If not a flag and no input file yet, treat as input file
                if (arg && !arg.startsWith('-') && !options.inputFile) {
                    options.inputFile = arg;
                }
        }
    }

    return options;
}

/**
 * Print help message
 */
function printHelp(): void {
    console.log(`
JSON to CSV Converter - Convert NEAR accounting history JSON to CSV

Usage:
  node json-to-csv.js [options] <input-file>

Options:
  -i, --input <file>    Input JSON file path (required)
  -o, --output <file>   Output CSV file path (optional, defaults to input file with .csv extension)
  -h, --help            Show this help message

Description:
  Reads a JSON file generated by get-account-history.js and converts it to a CSV file
  suitable for import into spreadsheet software.

  Note: Timestamps must be present in the JSON data. If timestamps are missing, 
  re-run the data collection script (get-account-history.js) with the --enrich flag
  to fetch missing timestamps.

  The CSV file contains the following columns (human-friendly on left, technical on right):
    - change_block_height: Block where balance change occurred (used for sorting)
    - timestamp: ISO 8601 timestamp of the transfer
    - counterparty: The other account involved in the transfer
    - direction: "in" for incoming transfers, "out" for outgoing transfers
    - token_symbol: Human-readable token symbol (NEAR, USDT, wNEAR, etc.)
    - amount_whole_units: Amount transferred in whole units (with decimals applied)
    - balance_whole_units: Token balance after transfer (with decimals applied)
    - asset: Token contract ID (NEAR for native, contract address for FT/MT)
    - amount_raw: Amount transferred in base units (as string to prevent Excel issues)
    - token_balance_raw: Token balance in base units (as string)
    - transaction_hash: Transaction hash (can be used to look up transaction in explorers)
    - receipt_id: Receipt ID of the transfer

Examples:
  # Convert a JSON file to CSV
  node json-to-csv.js myaccount.near.json

  # Specify output file
  node json-to-csv.js -i myaccount.near.json -o accounting.csv

  # Using long options
  node json-to-csv.js --input myaccount.near.json --output accounting.csv
`);
}

/**
 * Main execution
 */
async function main(): Promise<void> {
    const options = parseArgs();

    if (options.help) {
        printHelp();
        process.exit(0);
    }

    if (!options.inputFile) {
        console.error('Error: Input file is required');
        printHelp();
        process.exit(1);
    }

    // Check if input file exists
    if (!fs.existsSync(options.inputFile)) {
        console.error(`Error: Input file not found: ${options.inputFile}`);
        process.exit(1);
    }

    // Set default output file
    if (!options.outputFile) {
        const inputPath = path.parse(options.inputFile);
        options.outputFile = path.join(inputPath.dir, `${inputPath.name}.csv`);
    }

    try {
        // Read and parse input file
        console.log(`Reading input file: ${options.inputFile}`);
        const inputData = fs.readFileSync(options.inputFile, 'utf-8');
        const history: AccountHistory = JSON.parse(inputData);

        // Validate basic structure
        if (!history.accountId || !Array.isArray(history.transactions)) {
            console.error('Error: Invalid JSON structure - missing accountId or transactions array');
            process.exit(1);
        }

        // Check for missing timestamps
        const transactionsWithTransfers = history.transactions.filter(t => t.transfers && t.transfers.length > 0);
        const missingTimestamps = transactionsWithTransfers.filter(t => t.timestamp === null).length;
        if (missingTimestamps > 0) {
            console.warn(`Warning: ${missingTimestamps} transaction(s) have missing timestamps.`);
            console.warn(`Run 'npm start -- --account ${history.accountId} --enrich' to fetch missing timestamps.`);
        }

        // Convert to CSV rows (now async)
        console.log('Fetching token metadata and converting to CSV...');
        const rows = await convertToCSVRows(history);
        console.log(`Found ${rows.length} transfers to export`);

        // Generate CSV content
        const csvContent = generateCSV(rows);

        // Write output file
        const outputDir = path.dirname(options.outputFile);
        if (outputDir && !fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(options.outputFile, csvContent);

        console.log(`CSV exported to: ${options.outputFile}`);
        console.log(`Total rows: ${rows.length}`);
    } catch (error: unknown) {
        const message = error instanceof Error ? error.message : String(error);
        console.error(`Error: ${message}`);
        process.exit(1);
    }
}

// Run if called directly
if (import.meta.url.startsWith('file:') && process.argv[1] === fileURLToPath(import.meta.url)) {
    main();
}

// Export for testing
export {
    convertToCSVRows,
    generateCSV,
    escapeCSV,
    formatTimestamp,
    getAssetName,
    getTokenBalance
};
export type { AccountHistory, TransactionEntry, TransferDetail, BalanceSnapshot, CSVRow, Changes, BalanceChange };
